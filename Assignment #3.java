import java.util.Scanner;

/* This Code is generated by Jahongir Hayitov */
public class Main {

    /** New scanner object to read. */
    private final Scanner scanner = new Scanner(System.in);

    /**
     * The main method which starts the whole program.
     * This method controls what will happen
     * @param args
     */
    public static void main(String[] args) {

        /*
         * Create main object from Main class
         * in order to access other private or other classes outside
         */
        Main main = new Main();

        // declare abstract calculator, because we don't know its type now, I use Integer for initialization
        Calculator calculator = new IntegerCalculator();

        // read the calculator type to detect operation set
        CalculatorType calculatorType = main.readCalculator();

        // if the calculator type is incorrect call fatalError and exit the program
        if (calculatorType.equals(CalculatorType.INCORRECT)) {
            main.reportFatalError("Wrong calculator type");
        }

        // if it is not any error then create calculator
        switch (calculatorType) {
            case INTEGER:
                calculator = new IntegerCalculator();
                break;
            case DOUBLE:
                calculator = new DoubleCalculator();
                break;
            case STRING:
                calculator = new StringCalculator();
                break;
            default:
                // If magical error occurs
                main.reportFatalError("Wrong calculator type");
        }

        // read the number of operations to implement
        int numberOfCommands = main.readCommandsNumber();

        // if the operation number is incorrect call fatalError and exit the program
        if (numberOfCommands == 0) {
            main.reportFatalError("Amount of commands is Not a Number");
        }

        while ((numberOfCommands--) > 0) {
            // Split the string into blocks
            try {
                String[] operationLine = main.scanner.nextLine().split(" ");

                // two operands a and b, for being calculated
                String a = operationLine[1];
                String b = operationLine[2];
                final int targetNumberOfOperationLine = 3;

                /* if arguments in the operation string more than or less than 3 -> Wrong Operation, else compute */
                if (operationLine.length == targetNumberOfOperationLine) {

                    // operationLine[0] is the operation symbol *,+,-,/
                    OperationType operationType = main.parseOperation(operationLine[0]);

                    switch (operationType) {
                        case ADDITION:
                            System.out.println(calculator.add(a, b));
                            break;
                        case SUBTRACTION:
                            System.out.println(calculator.subtract(a, b));
                            break;
                        case MULTIPLICATION:
                            System.out.println(calculator.multiply(a, b));
                            break;
                        case DIVISION:
                            System.out.println(calculator.divide(a, b));
                            break;
                        default:
                            System.out.println("Wrong operation type");
                    }

                } else {

                    System.out.println("Wrong operation type");

                }
            } catch (Exception error) {
                System.out.println("Wrong operation type");
            }
        }

    }

    /**
     * For scanning the type of the Calculator.
     * @return CalculatorType
     */
    private CalculatorType readCalculator() {
        try {
            // scan the name of the calc. type
            String scannedTypeName = scanner.nextLine();
            // iterate through the enum constant values to find calculator type
            for (CalculatorType typeName : CalculatorType.values()) {
                if (scannedTypeName.equals(typeName.getValue())) {
                    return typeName;
                }
            }
        } catch (Exception e) {
            // Some ERROR occurs so return INCORRECT
            return CalculatorType.INCORRECT;
        }

        // if Calculator type is not found inside the enum list -> INCORRECT
        return CalculatorType.INCORRECT;
    }

    /** read how many number of commands(operations) we have -> integer.
     * @return int
     */
    private int readCommandsNumber() {
        try {
            // read with double because it can be some tricky test case
            double numberOfCommands = Double.parseDouble(scanner.nextLine());
            final int minNumberOfCommands = 1;
            final int maxNumberOfCommands = 50;
            // (double)n == (int)n  and  n>=1  and n<=50  -> CORRECT
            if (numberOfCommands == (int) numberOfCommands
                    && numberOfCommands >= minNumberOfCommands
                    && numberOfCommands <= maxNumberOfCommands) {
                return (int) numberOfCommands;
            } else {
                return 0;
            }
        } catch (Exception error) {
            // Something incorrect = 0
            return 0;
        }
    }

    /**
     * Detect which type of operation.
     * <ul>
     *     <li>Addition ( + )</li>
     *     <li>Subtraction ( - )</li>
     *     <li>Multiplication ( * )</li>
     *     <li>Division ( / )</li>
     * </ul>
     * @param operation
     * @return OperationType
     */
    private OperationType parseOperation(String operation) {
        for (OperationType operationType : OperationType.values()) {
            if (operationType.getValue().equals(operation)) {
                return operationType;
            }
        }
        return OperationType.INCORRECT;
    }

    private void reportFatalError(String err) {
        // If some fatal error occurs, then print error and exit from program
        System.out.println(err);
        System.exit(0);
    }

    // This is the end of the Main class
}

/**
 * Abstract Calculator which has 4 main operation.
 * We can identify the type of this by reading input
 * ,and we can inherit this class as a parent
 */
abstract class Calculator {
    /* As we said we have 4 operation but each has not its body */
    public abstract String add(String a, String b);
    public abstract String subtract(String a, String b);
    public abstract String multiply(String a, String b);
    public abstract String divide(String a, String b);
}

/**
 * Inside the IntegerCalculator.
 * We have to declare (override) methods
 * because they were previously declared as an abstract
*/
class IntegerCalculator extends Calculator {
    // Addition in Integer type
    @Override
    public String add(String a, String b) {
        int num1;
        int num2;
        try {
            num1 = Integer.parseInt(a);
            num2 = Integer.parseInt(b);
            return Integer.toString(num1 + num2);
        } catch (Exception error) {
            return "Wrong argument type";
        }
    }

    // Subtraction in Integer type
    @Override
    public String subtract(String a, String b) {
        int num1;
        int num2;
        try {
            num1 = Integer.parseInt(a);
            num2 = Integer.parseInt(b);
            return Integer.toString(num1 - num2);
        } catch (Exception error) {
            return "Wrong argument type";
        }
    }

    // Multiplication in Integer type
    @Override
    public String multiply(String a, String b) {
        int num1;
        int num2;
        try {
            num1 = Integer.parseInt(a);
            num2 = Integer.parseInt(b);
            return Integer.toString(num1 * num2);
        } catch (Exception error) {
            return "Wrong argument type";
        }
    }

    // Division in Integer type
    @Override
    public String divide(String a, String b) {
        int num1;
        int num2;
        try {
            num1 = Integer.parseInt(a);
            num2 = Integer.parseInt(b);
            if (num2 == 0) {
                return "Division by zero";
            }
            return Integer.toString(num1 / num2);
        } catch (Exception error) {
            return "Wrong argument type";
        }
    }
}

/**
 * Inside the DoubleCalculator.
 * We have to declare (override) methods
 * because they were previously declared as an abstract
 */
class DoubleCalculator extends Calculator {
    // Addition in Double type
    @Override
    public String add(String a, String b) {
        double num1;
        double num2;
        try {
            num1 = Double.parseDouble(a);
            num2 = Double.parseDouble(b);
            return Double.toString(num1 + num2);
        } catch (Exception error) {
            return "Wrong argument type";
        }
    }

    // Subtraction in Double type
    @Override
    public String subtract(String a, String b) {
        double num1;
        double num2;
        try {
            num1 = Double.parseDouble(a);
            num2 = Double.parseDouble(b);
            return Double.toString(num1 - num2);
        } catch (Exception error) {
            return "Wrong argument type";
        }
    }

    // Multiplication in Double type
    @Override
    public String multiply(String a, String b) {
        double num1;
        double num2;
        try {
            num1 = Double.parseDouble(a);
            num2 = Double.parseDouble(b);
            return Double.toString(num1 * num2);
        } catch (Exception error) {
            return "Wrong argument type";
        }
    }

    // Division in Double type
    @Override
    public String divide(String a, String b) {
        double num1;
        double num2;
        try {
            num1 = Double.parseDouble(a);
            num2 = Double.parseDouble(b);
            if (num2 == 0.0) {
                return "Division by zero";
            }
            return Double.toString(num1 / num2);
        } catch (Exception error) {
            return "Wrong argument type";
        }
    }
}

/**
 * Inside the StringCalculator.
 * We have to declare (override) methods
 * because they were previously declared as an abstract
 * there are some prohibited operation in String type
 * */
class StringCalculator extends Calculator {

    // Addition in String type
    public String add(String a, String b) {
        return a + b;
    }

    // Subtraction in String type is prohibited
    public String subtract(String a, String b) {
        return "Unsupported operation for strings";
    }


    // Division in String type is prohibited
    public String multiply(String a, String b) {
        double num;
        try {
            num = Double.parseDouble(b);
            // Special Case
            if (num == (int) num && num > 0) {
                // I use String Builder to copy the string and append it to the end
                StringBuilder string = new StringBuilder("");
                /* String multiply algorithm by using StringBuilder and its append method */
                for (int i = 0; i < (int) num; i++) {
                    string.append(a);
                }
                return string.toString();
            } else {
                return "Wrong argument type";
            }
        } catch (Exception error) {
            return "Wrong argument type";
        }
    }

    // Division in String type is prohibited
    public String divide(String a, String b) {
        return "Unsupported operation for strings";
    }
}

/**
 * ENUM constants to make life easy.
 * I used getValue for my better understanding
*/
enum CalculatorType {
    /** Identify Calculators Type. *
     * If Integer then we use Integer operations
     */
    INTEGER("INTEGER"),
    /** Identify Calculators Type. *
     * If Double then we use Double operations
     */
    DOUBLE("DOUBLE"),
    /** Identify Calculators Type. *
     * If String then we use String operations
     */
    STRING("STRING"),
    /** Identify Calculators Type. *
     * If Incorrect then we should warn the user
     */
    INCORRECT("INCORRECT");

    /** Methods and operations.
     * value - holding enums argument values
     * getValue() - method which return this value
     * */
    // Methods and operations
    private final String value;

    CalculatorType(String initialValue) {
        this.value = initialValue;
    }

    public String getValue() {
        return value;
    }

}

enum OperationType {
    /** Identify Operation Type. *
     * If + then we add
     */
    ADDITION("+"),
    /** Identify Operation Type. *
     * If * then we multiply
     */
    MULTIPLICATION("*"),
    /** Identify Operation Type. *
     * If - then we subtract
     */
    SUBTRACTION("-"),
    /** Identify Operation Type. *
     * If / then we divide
     */
    DIVISION("/"),
    /** Identify Operation Type. *
     * else we use warn the user
     */
    INCORRECT("~");

    /** Methods and operations.
     * value - holding enums argument values
     * getValue() - method which return this value
     * */
    private final String value;

    OperationType(String initialValue) {
        this.value = initialValue;
    }

    public String getValue() {
        return value;
    }

}
