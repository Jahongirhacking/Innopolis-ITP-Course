import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;


/* This Code is generated by Jahongir Hayitov */
public class Main {

    /**
     * Output Error message and exit.
     * @param message String
     * @throws IOException Exception
     */
    private void output(String message) throws IOException {
        FileWriter file = new FileWriter("output.txt");
        PrintWriter outFile = new PrintWriter(file);
        System.out.println(message);
        outFile.print(message);
        outFile.close();
        System.exit(0);
    }

    /**
     * The main method which starts the whole program.
     * This method controls what will happen
     * @param args convention
     */
    public static void main(String[] args) throws IOException {
        /*
         * Main method to implement.
         */
        Main main = new Main();
        // check number of kings
        int numberOfBlackKing = 0;
        int numberOfWhiteKing = 0;
        /* Read input and output. */
        try {
            final File inFile = new File("input.txt");
            final Scanner sc = new Scanner(inFile);
            // if there is nothing
            if (!sc.hasNextLine()) {
                throw new InvalidInputException();
            }
            final int boardSize = sc.nextInt();
            // Limits
            final int upperLimitOfBoardSize = 1000;
            final int lowerLimitOfBoardSize = 3;
            // Check with lower and upper limits for chessboard size
            if (boardSize < lowerLimitOfBoardSize || boardSize > upperLimitOfBoardSize) {
                throw new InvalidBoardSizeException();
            }
            /*
             * Crete new chessboard to put the pieces.
             */
            Board chessBoard = new Board(boardSize);
            // if there is no piece number
            if (!sc.hasNextLine()) {
                throw new InvalidNumberOfPiecesException();
            }
            // read number of pieces
            int numberOfPieces = sc.nextInt();
            // limits
            final int lowerLimitOfPieces = 2;
            // check lower and upper limits of pieces
            if (numberOfPieces < lowerLimitOfPieces || numberOfPieces > boardSize * boardSize) {
                throw new InvalidNumberOfPiecesException();
            }
            /*
             * An array saves the pieces ordered.
             */
            Position[] arr = new Position[numberOfPieces];
            for (int iter = 0; iter < numberOfPieces; iter++) {
                // Name of the piece
                String nameOfPiece = sc.next();
                if (!(nameOfPiece.equals("Knight") || nameOfPiece.equals("King") || nameOfPiece.equals("Pawn")
                        || nameOfPiece.equals("Bishop") || nameOfPiece.equals("Rook") || nameOfPiece.equals("Queen"))) {
                    throw new InvalidPieceNameException();
                }
                /*
                 * Read piece color by using enum.
                 */
                PieceColor color = PieceColor.INCORRECT.parse(sc.next());
                if (color.equals(PieceColor.INCORRECT)) {
                    throw new InvalidPieceColorException();
                }
                // If king then count it
                if (nameOfPiece.equals("King")) {
                    if (color.equals(PieceColor.WHITE)) {
                        numberOfWhiteKing++;
                        if (numberOfWhiteKing > 1) {
                            throw new InvalidGivenKingsException();
                        }
                    } else if (color.equals(PieceColor.BLACK)) {
                        numberOfBlackKing++;
                        if (numberOfBlackKing > 1) {
                            throw new InvalidGivenKingsException();
                        }
                    } else {
                        // Magic case
                        throw new InvalidPieceColorException();
                    }
                }
                // Coordinate of the position
                int x = sc.nextInt();
                int y = sc.nextInt();
                if (x < 1 || x > boardSize || y < 1 || y > boardSize) {
                    throw new InvalidPiecePositionException();
                }
                /*
                 * Create new position x- and y-axis.
                 */
                Position position = new Position(x, y);

                /*
                 *  We don't know chesspiece name first, so make it abstract.
                 */
                ChessPiece chessPiece;
                // conditions We can use switch
                if (nameOfPiece.equals("Knight")) {
                    chessPiece = new Knight(position, color);
                } else if (nameOfPiece.equals("King")) {
                    chessPiece = new King(position, color);
                } else if (nameOfPiece.equals("Pawn")) {
                    chessPiece = new Pawn(position, color);
                } else if (nameOfPiece.equals("Bishop")) {
                    chessPiece = new Bishop(position, color);
                } else if (nameOfPiece.equals("Rook")) {
                    chessPiece = new Rook(position, color);
                } else if (nameOfPiece.equals("Queen")) {
                    chessPiece = new Queen(position, color);
                } else {
                    // magic case
                    throw new InvalidPieceNameException();
                }
                /* put a piece to the board. */
                chessBoard.addPiece(chessPiece);
                /* save to memory to make with order. */
                arr[iter] = position;
            }

            // check number of kings each
            if (numberOfBlackKing != 1 || numberOfWhiteKing != 1) {
                throw new InvalidGivenKingsException();
            }

            // If pieces are more than given number
            if (sc.hasNext() && !sc.next().equals("")) {
                throw new InvalidNumberOfPiecesException();
            }


            /* Write the Answer. */
            FileWriter file = new FileWriter("output.txt");
            /* Output File. */
            PrintWriter outFile = new PrintWriter(file);
            for (Position pos : arr) {
                outFile.println(chessBoard.getPiecePossibleMovesCount(chessBoard.getPiece(pos)) + " "
                        + chessBoard.getPiecePossibleCapturesCount(chessBoard.getPiece(pos)));
            }
            outFile.close();

        } catch (Exception e) {
            if (e.getMessage() == null) {
                main.output("Invalid number of pieces\n");
            }
            main.output(e.getMessage());
        }

    }

    // This is the end of the Main class
}

/**
 * Position class.
 * to implement operation on positions, find the position of the piece...
 */
class Position {
    /** Coordinate of X axis. */
    private final int x;
    /** Coordinate of Y axis. */
    private final int y;

    /**
     * Position constructor.
     * @param valueX int
     * @param valueY int
     */
    Position(int valueX, int valueY) {
        this.x = valueX;
        this.y = valueY;
    }

    /** get the value of x.
     * @return int
     * */
    public int getX() {
        return this.x;
    }

    /** get the value of y.
     * @return int
     * */
    public int getY() {
        return this.y;
    }

    /** get coordinate as a String.
     * @return String
     * */
    public String toString() {
        return (x + " " + y);
    }
}


/**
 * Board class to create board.
 */
class Board {
    /**
     * A map which stores coordinate as a key and piece as a value.
     * f-e: {"4 7", "King"}
     */
    private final Map<String, ChessPiece> positionsToPieces = new HashMap<>();
    /** Size of the board.
     * it should be NxN
     */
    private final int size;

    /**
     * Board constructor.
     * @param sizeOfTheBoard int
     */
    Board(int sizeOfTheBoard) {
        // If board size is out of the limit then print error
        this.size = sizeOfTheBoard;
    }

    /**
     * Count Possible Moves.
     * @param piece ChessPiece
     * @return int
     */
    public int getPiecePossibleMovesCount(ChessPiece piece) {
        return piece.getMovesCount(this.positionsToPieces, this.size);
    }

    /**
     * Count Possible Captures.
     * @param piece ChessPiece
     * @return int
     */
    public int getPiecePossibleCapturesCount(ChessPiece piece) {
        return piece.getCapturesCount(this.positionsToPieces, this.size);
    }

    /**
     * Add the piece to the board.
     * @param piece ChessPiece
     * @throws InvalidPiecePositionException Exception
     */
    public void addPiece(ChessPiece piece) throws InvalidPiecePositionException {
        /*
         * add piece to the board.
         * if coordinate is taken then throw error
         */
        if (!(this.positionsToPieces.containsKey(piece.getPosition().toString()))) {
            this.positionsToPieces.put(piece.getPosition().toString(), piece);
        } else {
            throw new InvalidPiecePositionException();
        }
    }

    public ChessPiece getPiece(Position position) {
        return this.positionsToPieces.get(position.toString());
    }
}

/**
 * Interface Bishop movement.
 */
interface BishopMovement {
    /**
     * Count diagonal movements.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return abstract
     */
    int getDiagonalMovesCount(Position position, PieceColor color,
                              Map<String, ChessPiece> positions, int boardSize);
    /**
     * Count diagonal captures.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return abstract
     */
    int getDiagonalCapturesCount(Position position, PieceColor color,
                                 Map<String, ChessPiece> positions, int boardSize);
}


 /** Interface Bishop movement. */
interface RookMovement {
    /**
     * Count orthogonal movements.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return abstract
     */
    int getOrthogonalMovesCount(Position position, PieceColor color,
                                Map<String, ChessPiece> positions, int boardSize);
    /**
     * Count orthogonal captures.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return abstract
     */
    int getOrthogonalCapturesCount(Position position, PieceColor color,
                                   Map<String, ChessPiece> positions, int boardSize);
}

/**
 * Abstract ChessPiece.
 * because we don't know the exact piece beforehand
 */
abstract class ChessPiece {
    /** Position of the chess piece. */
    protected Position position;
    /** Color of the chess piece. */
    protected PieceColor color;
    /** # captures of the chess piece. */
    protected int numberOfCaptures = 0;
    /** # moves of the chess piece. */
    protected int numberOfMoves = 0;

    /**
     * ChessPiece constructor.
     * @param positionOfThePiece Position
     * @param colorOfThePiece PieceColor
     */
    ChessPiece(Position positionOfThePiece, PieceColor colorOfThePiece) {
        this.position = positionOfThePiece;
        this.color = colorOfThePiece;
    }

    /**
     * get the position of the element.
     * @return position
     */
    public Position getPosition() {
        return position;
    }

    /**
     * get the color of the element.
     * @return color
     */
    public PieceColor getColor() {
        return color;
    }

    /**
     * Abstract method to count the moves.
     * @param positions Map
     * @param boardSize int
     * @return abstract
     */
    public abstract int getMovesCount(Map<String, ChessPiece> positions, int boardSize);
    /**
     * Abstract method to count the captures.
     * @param positions Map
     * @param boardSize int
     * @return abstract
     */
    public int getCapturesCount(Map<String, ChessPiece> positions, int boardSize) {
        return this.numberOfCaptures;
    }
}

/**
 * Knight piece.
 */
class Knight extends ChessPiece {
    /**
     * Constructor of Knight.
     * @param position Position
     * @param color PieceColor
     */
    Knight(Position position, PieceColor color) {
        super(position, color);
    }

    /**
     * Count the moves.
     * @param positions Map
     * @param boardSize int
     * @return numberOfMoves int
     */
    @Override
    public int getMovesCount(Map<String, ChessPiece> positions, int boardSize) {
        // properties
        int x = this.position.getX();
        int y = this.position.getY();
        PieceColor color = this.color;

        // count valid ways
        int movedY;
        int movedX;
        final int twoMoves = 2;
        final int oneMove = 1;
        final int totalCombination = 8;

        // an array controls the movement
        int[][] arr = {{twoMoves, oneMove}, {twoMoves, -oneMove}, {-twoMoves, oneMove},
                {-twoMoves, -oneMove}, {oneMove, twoMoves}, {oneMove, -twoMoves},
                {-oneMove, twoMoves}, {-oneMove, -twoMoves}};

        // full algorithm to iterate through the board
        for (int i = 0; i < totalCombination; i++) {
            movedY = y + arr[i][1];
            movedX = x + arr[i][0];

            if (movedY >= 1 && movedY <= boardSize && movedX >= 1 && movedX <= boardSize) {
                String pos = (movedX + " " + movedY);
                if (!(positions.get(pos) != null && positions.get(pos).getColor().equals(color))) {
                    this.numberOfMoves++;
                    if (positions.get(pos) != null && !positions.get(pos).getColor().equals(color)) {
                        this.numberOfCaptures++;
                    }
                }
            }
        }

        return this.numberOfMoves;
    }
}

/**
 * Knight piece.
 */
class King extends ChessPiece {
    /**
     * constructor of King.
     * @param position Position
     * @param color PieceColor
     */
    King(Position position, PieceColor color) {
        super(position, color);
    }

    /**
     * Count the moves.
     * @param positions Map
     * @param boardSize int
     * @return numberOfMoves
     */
    @Override
    public int getMovesCount(Map<String, ChessPiece> positions, int boardSize) {
        // properties
        int x = this.position.getX();
        int y = this.position.getY();
        PieceColor color = this.color;

        final int oneMove = 1;
        final int noMove = 0;
        final int totalCombination = 8;

        // count valid ways
        int movedY;
        int movedX;
        // an array controls the movement
        int[][] arr = {{oneMove, noMove}, {oneMove, oneMove}, {noMove, oneMove},
                {-oneMove, oneMove}, {-oneMove, noMove}, {-oneMove, -oneMove},
                {noMove, -oneMove}, {oneMove, -oneMove}};

        // full algorithm to iterate through the board
        for (int i = 0; i < totalCombination; i++) {
            movedY = y + arr[i][1];
            movedX = x + arr[i][0];

            if (movedY >= 1 && movedY <= boardSize && movedX >= 1 && movedX <= boardSize) {
                String pos = (movedX + " " + movedY);
                if (!(positions.get(pos) != null && positions.get(pos).getColor().equals(color))) {
                    this.numberOfMoves++;
                    if (positions.get(pos) != null && !positions.get(pos).getColor().equals(color)) {
                        this.numberOfCaptures++;
                    }
                }
            }
        }

        return this.numberOfMoves;
    }

}

/**
 * Pawn piece.
 */
class Pawn extends ChessPiece {
    /**
     * constructor of Pawn.
     * @param position Position
     * @param color PieceColor
     */
    Pawn(Position position, PieceColor color) {
        super(position, color);
    }

    /**
     * Count the moves.
     * @param positions Map
     * @param boardSize int
     * @return numberOfMoves
     */
    @Override
    public int getMovesCount(Map<String, ChessPiece> positions, int boardSize) {
        // properties
        int x = this.position.getX();
        int y = this.position.getY();
        PieceColor color = this.color;

        // count valid ways
        int movedY;
        int movedX;
        int move = 1;
        if (color.equals(PieceColor.BLACK)) {
            move = -1;
        }

        movedY = y + move;
        movedX = x;

        // full algorithm to iterate through the board
        if (movedY >= 1 && movedY <= boardSize && movedX >= 1 && movedX <= boardSize) {
            String pos = (movedX + " " + movedY);
            if (positions.get(pos) == null) {
                this.numberOfMoves++;
            }

            // Check if opponent exist
            movedX = x - 1;
            pos = (movedX + " " + movedY);
            if (positions.get(pos) != null && !positions.get(pos).getColor().equals(color)) {
                this.numberOfCaptures++;
            }

            movedX = x + 1;
            pos = (movedX + " " + movedY);
            if (positions.get(pos) != null && !positions.get(pos).getColor().equals(color)) {
                this.numberOfCaptures++;
            }
        }

        return (this.numberOfMoves + this.numberOfCaptures);
    }

}

/**
 * Bishop piece.
 */
class Bishop extends ChessPiece implements BishopMovement {
    /**
     * constructor of Bishop.
     * @param position Position
     * @param color PieceColor
     */
    Bishop(Position position, PieceColor color) {
        super(position, color);
    }

    /**
     * count the moves via interface.
     * @param positions Map
     * @param boardSize int
     * @return numberOfMoves
     */
    @Override
    public int getMovesCount(Map<String, ChessPiece> positions, int boardSize) {
        return this.getDiagonalMovesCount(this.position, this.color, positions, boardSize);
    }

    /**
     * count the captures via interface.
     * @param positions Map
     * @param boardSize int
     * @return numberOfMoves int
     */
    @Override
    public int getCapturesCount(Map<String, ChessPiece> positions, int boardSize) {
        return this.getDiagonalCapturesCount(this.position, this.color, positions, boardSize);
    }

    /**
     * count diagonal moves.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return numberOfMoves
     */
    @Override
    public int getDiagonalMovesCount(Position position, PieceColor color,
                                     Map<String, ChessPiece> positions, int boardSize) {
        // properties
        int x = position.getX();
        int y = position.getY();

        // count valid ways
        int movedY;
        int movedX;
        final int oneMove = 1;
        final int totalCombination = 4;
        int[][] arr = {{oneMove, oneMove}, {oneMove, -oneMove},
                {-oneMove, oneMove}, {-oneMove, -oneMove}};

        // full algorithm to iterate through the board
        for (int i = 0; i < totalCombination; i++) {
            movedY = y;
            movedX = x;

            while (true) {
                movedY += arr[i][1];
                movedX += arr[i][0];
                String pos = (movedX + " " + movedY);

                if (!(movedY >= 1 && movedY <= boardSize && movedX >= 1 && movedX <= boardSize)) {
                    break;
                }

                if (positions.get(pos) != null && positions.get(pos).getColor().equals(color)) {
                    break;
                }

                if (positions.get(pos) != null && !positions.get(pos).getColor().equals(color)) {
                    this.numberOfMoves++;
                    this.numberOfCaptures++;
                    break;
                }

                if (positions.get(pos) == null) {
                    this.numberOfMoves++;
                }

            }
        }

        return this.numberOfMoves;
    }

    /**
     * count diagonal captures.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return numberOfCaptures int
     */
    @Override
    public int getDiagonalCapturesCount(Position position, PieceColor color,
                                        Map<String, ChessPiece> positions, int boardSize) {
        return this.numberOfCaptures;
    }
}

/**
 * Rook piece.
 */
class Rook extends ChessPiece implements RookMovement {
    /**
     * constructor of Rook.
     * @param position Position
     * @param color PieceColor
     */
    Rook(Position position, PieceColor color) {
        super(position, color);
    }

    /**
     * count the moves.
     * @param positions Map
     * @param boardSize int
     * @return numberOfMoves int
     */
    @Override
    public int getMovesCount(Map<String, ChessPiece> positions, int boardSize) {
        return this.getOrthogonalMovesCount(this.position, this.color, positions, boardSize);
    }

    /**
     * count the captures.
     * @param positions Map
     * @param boardSize int
     * @return numberOfCaptures int
     */
    @Override
    public int getCapturesCount(Map<String, ChessPiece> positions, int boardSize) {
        return this.getOrthogonalCapturesCount(this.position, this.color, positions, boardSize);
    }

    /**
     * count orthogonal moves.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return int
     */
    @Override
    public int getOrthogonalMovesCount(Position position, PieceColor color,
                                       Map<String, ChessPiece> positions, int boardSize) {
        // properties
        int x = position.getX();
        int y = position.getY();

        // count valid ways
        int movedY;
        int movedX;

        final int oneMove = 1;
        final int noMove = 0;
        final int totalCombination = 4;

        int[][] arr = {{oneMove, noMove}, {noMove, -oneMove},
                {-oneMove, noMove}, {noMove, oneMove}};

        // full algorithm to iterate through the board
        for (int i = 0; i < totalCombination; i++) {
            movedY = y;
            movedX = x;
            while (true) {
                movedY += arr[i][1];
                movedX += arr[i][0];
                String pos = (movedX + " " + movedY);

                if (!(movedY >= 1 && movedY <= boardSize && movedX >= 1 && movedX <= boardSize)) {
                    break;
                }

                if (positions.get(pos) != null && positions.get(pos).getColor().equals(color)) {
                    break;
                }

                if (positions.get(pos) != null && !positions.get(pos).getColor().equals(color)) {
                    this.numberOfMoves++;
                    this.numberOfCaptures++;
                    break;
                }

                if (positions.get(pos) == null) {
                    this.numberOfMoves++;
                }

            }
        }

        return this.numberOfMoves;
    }

    /**
     * count orthogonal captures.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return numberOfCaptures int
     */
    @Override
    public int getOrthogonalCapturesCount(Position position, PieceColor color,
                                          Map<String, ChessPiece> positions, int boardSize) {
        return this.numberOfCaptures;
    }
}

/**
 * Queen piece.
 */
class Queen extends ChessPiece implements BishopMovement, RookMovement {
    /**
     * Constructor of Queen.
     * @param position Position
     * @param color PieceColor
     */
    Queen(Position position, PieceColor color) {
        super(position, color);
    }

    /**
     * count the moves.
     * @param positions Map
     * @param boardSize int
     * @return int
     */
    @Override
    public int getMovesCount(Map<String, ChessPiece> positions, int boardSize) {
        getDiagonalMovesCount(this.position, this.color, positions, boardSize);
        return getOrthogonalMovesCount(this.position, this.color, positions, boardSize);
    }

    /**
     * count the captures.
     * @param positions Map
     * @param boardSize int
     * @return int
     */
    @Override
    public int getCapturesCount(Map<String, ChessPiece> positions, int boardSize) {
        getDiagonalCapturesCount(this.position, this.color, positions, boardSize);
        return getOrthogonalCapturesCount(this.position, this.color, positions, boardSize);
    }

    /**
     * count the diagonal moves.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return int
     */
    @Override
    public int getDiagonalMovesCount(Position position, PieceColor color,
                                     Map<String, ChessPiece> positions, int boardSize) {
        // properties
        int x = position.getX();
        int y = position.getY();

        // count valid ways
        int movedY;
        int movedX;
        final int oneMove = 1;
        final int totalCombination = 4;
        int[][] arr = {{oneMove, oneMove}, {oneMove, -oneMove},
                {-oneMove, oneMove}, {-oneMove, -oneMove}};

        // full algorithm to iterate through the board
        for (int i = 0; i < totalCombination; i++) {
            movedY = y;
            movedX = x;
            while (true) {
                movedY += arr[i][1];
                movedX += arr[i][0];
                String pos = (movedX + " " + movedY);

                if (!(movedY >= 1 && movedY <= boardSize && movedX >= 1 && movedX <= boardSize)) {
                    break;
                }

                if (positions.get(pos) != null && positions.get(pos).getColor().equals(color)) {
                    break;
                }

                if (positions.get(pos) != null && !positions.get(pos).getColor().equals(color)) {
                    this.numberOfMoves++;
                    this.numberOfCaptures++;
                    break;
                }

                if (positions.get(pos) == null) {
                    this.numberOfMoves++;
                }

            }
        }

        return this.numberOfMoves;
    }

    /**
     * count the diagonal captures.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return int
     */
    @Override
    public int getDiagonalCapturesCount(Position position, PieceColor color,
                                        Map<String, ChessPiece> positions, int boardSize) {
        return this.numberOfCaptures;
    }

    /**
     * count orthogonal moves.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return int
     */
    @Override
    public int getOrthogonalMovesCount(Position position, PieceColor color,
                                       Map<String, ChessPiece> positions, int boardSize) {
        // properties
        int x = position.getX();
        int y = position.getY();

        // count valid ways
        int movedY;
        int movedX;

        final int oneMove = 1;
        final int noMove = 0;
        final int totalCombination = 4;

        int[][] arr = {{oneMove, noMove}, {noMove, -oneMove},
                {-oneMove, noMove}, {noMove, oneMove}};

        // full algorithm to iterate through the board
        for (int i = 0; i < totalCombination; i++) {
            movedY = y;
            movedX = x;
            while (true) {
                movedY += arr[i][1];
                movedX += arr[i][0];
                String pos = (movedX + " " + movedY);

                if (!(movedY >= 1 && movedY <= boardSize && movedX >= 1 && movedX <= boardSize)) {
                    break;
                }

                if (positions.get(pos) != null && positions.get(pos).getColor().equals(color)) {
                    break;
                }

                if (positions.get(pos) != null && !positions.get(pos).getColor().equals(color)) {
                    this.numberOfMoves++;
                    this.numberOfCaptures++;
                    break;
                }

                if (positions.get(pos) == null) {
                    this.numberOfMoves++;
                }

            }
        }

        return this.numberOfMoves;
    }

    /**
     * count orthogonal captures.
     * @param position Position
     * @param color Color
     * @param positions Map
     * @param boardSize int
     * @return int
     */
    @Override
    public int getOrthogonalCapturesCount(Position position, PieceColor color,
                                          Map<String, ChessPiece> positions, int boardSize) {
        return this.numberOfCaptures;
    }
}

/**
 * ENUM constants to make life easy.
 * I used getValue for my better understanding
 */
enum PieceColor {
    /** Identify Piece Color. */
    WHITE,
    /** Identify Piece Color. */
    BLACK,
    /** Identify Piece Color. */
    INCORRECT;



    /** Methods and operations.
     * color - holding enums argument colors
     * parse(String) - string to enum
     * @return PieceColor
     * @param colorValue String
     * */

    public PieceColor parse(String colorValue) {
        if (colorValue.equals("Black")) {
            return BLACK;
        } else if (colorValue.equals("White")) {
            return WHITE;
        } else {
            return INCORRECT;
        }
    }

}

/**
 * If Board size is invalid (3<=N<=1000).
 */
class InvalidBoardSizeException extends Exception {
    /**
     * constructor of Invalid Board.
     */
    InvalidBoardSizeException() {
        // Call constructor of parent Exception
        super("Invalid board size\n");
    }
}

/**
 * If Number of pieces is invalid (2<=M<=N^2).
 */
class InvalidNumberOfPiecesException extends Exception {
    /**
     * constructor of Invalid number of Pieces.
     */
    InvalidNumberOfPiecesException() {
        // Call constructor of parent Exception
        super("Invalid number of pieces\n");
    }
}

/**
 * If piece name is invalid (Pawn, King, Queen, Knight, Rook, Bishop).
 */
class InvalidPieceNameException extends Exception {
    /**
     * constructor of Invalid Name.
     */
    InvalidPieceNameException() {
        // Call constructor of parent Exception
        super("Invalid piece name\n");
    }
}

/**
 * If piece color is invalid (Black, White).
 */
class InvalidPieceColorException extends Exception {
    /**
     * constructor of Invalid Color.
     */
    InvalidPieceColorException() {
        // Call constructor of parent Exception
        super("Invalid piece color\n");
    }
}

/**
 * If piece position is invalid ([1,N]).
 */
class InvalidPiecePositionException extends Exception {
    /**
     * constructor of Invalid Position.
     */
    InvalidPiecePositionException() {
        // Call constructor of parent Exception
        super("Invalid piece position\n");
    }
}

/**
 * If Kings number is invalid (each has only 1).
 */
class InvalidGivenKingsException extends Exception {
    /**
     * constructor of Invalid Given Kings.
     */
    InvalidGivenKingsException() {
        // Call constructor of parent Exception
        super("Invalid given Kings\n");
    }
}

/**
 * If input is invalid.
 */
class InvalidInputException extends Exception {
    /**
     * constructor of Invalid Input.
     */
    InvalidInputException() {
        // Call constructor of parent Exception
        super("Invalid Input\n");
    }
}
